/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "stm32f103xx_uart.h"
#include "stm32f103xx_spi.h"

#define SLAVE_SELECT_PIN						GPIO_PIN_4
#define Master_CTRL_BUS							GPIO_PIN_RESET
#define Master_FREE_BUS							GPIO_PIN_SET


#define MCU_ACT_as_Master
//#define MCU_ACT_as_Slave


uint16_t data_1;

void UART_Interrupt_AfterRx(void)
{
#ifdef MCU_ACT_as_Master
	MCAL_UART_Recieve(uart1, &data_1, PollingDisable);
	MCAL_UART_Transmit(uart1, &data_1, PollingEnable);
	//Send to SPI
	MCAL_GPIO_WRITE_PIN(GPIOA, SLAVE_SELECT_PIN, Master_CTRL_BUS);
	MCAL_SPI_Tx_Rx(SPI1, &data_1, Polling_Enable);
	MCAL_GPIO_WRITE_PIN(GPIOA, SLAVE_SELECT_PIN, Master_FREE_BUS);
#endif
}

void SPI_IRQ_After_Rx(struct S_IRQ_SRC irq_src)
{
#ifdef MCU_ACT_as_Slave
	if(irq_src.RXNE)
	{
		data_1 = 0xF;
		MCAL_SPI_Tx_Rx(SPI1, &data_1, Polling_Disable);
		MCAL_UART_Transmit(uart1, &data_1, PollingEnable);
	}
#endif
}


int main(void)
{
	USARTx_CFG uart_configgg;
	uart_configgg.BaudRate = UARTx_BAUDRATE_115200;
	uart_configgg.WordLengh = WordLength_8;
	uart_configgg.StopBit = StopBit_1;
	uart_configgg.Parity = Parity_Disable;
	uart_configgg.TX_RX_Enable = UART_TxRxEnable;
	uart_configgg.HwFlowCtrl = CTS_RTS_Disable;
	uart_configgg.Interrupt_Condition = UARTx_IRQ_Rx_dataReady_Enable;
	uart_configgg.P_UART_IRQ = UART_Interrupt_AfterRx;
	MCAL_UART_INIT(uart1, &uart_configgg);

	SPI_Config SPI1_CFG;
	SPI1_CFG.CLKPhase = SPI_CLKPhase_2ndEdge_capture;
	SPI1_CFG.CLKPolarity = SPI_CLKPolarity_HIGH_When_idle;
	SPI1_CFG.DataSize = SPI_DataSize_8BIT;
	SPI1_CFG.Frame_Format = SPI_Frame_Format_MSB;
	//Assume by default pclk2 = 8MHz
	SPI1_CFG.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI1_CFG.Communication_Mode = SPI_Directional_2Lines;
#ifdef MCU_ACT_as_Master
	SPI1_CFG.Device_Mode = SPI_Device_Mode_MASTER;
	SPI1_CFG.IRQ_Enable = SPI_IRQ_Enable_None;
	SPI1_CFG.NSS = SPI_NSS_Software_SSI_Set;
	SPI1_CFG.P_IRQ_CallBack = NULL
	//Configure Slave Select on Port_A By GPIO
	PIN_CFG_TypeDef GPIO_SPI1_PIN_SS;
	GPIO_SPI1_PIN_SS.PIN_NUMBER = SLAVE_SELECT_PIN;
	GPIO_SPI1_PIN_SS.__PinMode = OUTPUT_MODE;
	GPIO_SPI1_PIN_SS.CNF_OUTPUT_CASE = GPOutput_Push_pull;
	GPIO_SPI1_PIN_SS.MODE_CASE = Output_mode_max_speed_10MHz;
	MCAL_GPIO_INIT(GPIOA, &GPIO_SPI1_PIN_SS);

	MCAL_GPIO_WRITE_PIN(GPIOA, SLAVE_SELECT_PIN, Master_FREE_BUS);
#endif

#ifdef MCU_ACT_as_Slave
	SPI1_CFG.Device_Mode = SPI_Device_Mode_SLAVE;
	SPI1_CFG.IRQ_Enable = SPI_IRQ_Enable_RXNEIE;
	SPI1_CFG.NSS = SPI_NSS_Hard_Slave;
	SPI1_CFG.P_IRQ_CallBack = SPI_IRQ_After_Rx;
#endif
	MCAL_SPI_Init(SPI1, &SPI1_CFG);
    while(1)
    {


    }
    return 0;
}
